---
// src/components/FeedEntry.astro
import type { CollectionEntry } from 'astro:content';
import { Image } from 'astro:assets';
// MODIFICATION: Import render function from MarkdownRenderer
import { render as parseMarkdown } from './MarkdownRenderer.astro';

type BaseBlock = { type: string };
type ContentBlock = NonNullable<CollectionEntry<'feed'>['data']['contentBlocks']>[number];

interface Props {
    entry: CollectionEntry<'feed'>;
}

const { entry } = Astro.props;
const { slug, data } = entry;

const formattedDate = data.date
    ? new Date(data.date).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
    })
    : null;

// MODIFICATION: Removed local parseMarkdown function, using imported one
// function parseMarkdown(markdownString?: string): string { ... } // REMOVED
---
<article class="feed-entry" id={slug}>
    <h3>{data.title || 'Untitled Entry'}</h3>
    {formattedDate && (
        <time class="feed-entry-date" datetime={data.date?.toISOString()}>{formattedDate}</time>
    )}

    <div class="feed-entry-blocks">
        {data.contentBlocks && data.contentBlocks.length > 0 ? (
            data.contentBlocks.map((block: ContentBlock, index: number) => {
                const galleryId = `gallery-${slug}-${index}`;
                const prevBtnId = `gallery-prev-${slug}-${index}`;
                const nextBtnId = `gallery-next-${slug}-${index}`;

                switch (block.type) {
                    case 'twoColumn':
                        return (
                            <div class="content-block block-two-column">
                                {block.left && (
                                    <div class="column left-column" set:html={parseMarkdown(block.left)}></div>
                                )}
                                {block.right && (
                                    <div class="column right-column" set:html={parseMarkdown(block.right)}></div>
                                )}
                            </div>
                        );

                    case 'fullWidthImage':
                        return block.image ? (
                            <div class="content-block block-full-width-image">
                                <Image
                                    src={block.image}
                                    alt={block.alt || ''}
                                    width={1200}
                                    height={900}
                                    format="webp"
                                    quality={80}
                                    loading="lazy"
                                    densities={[1, 1.5, 2]}
                                />
                            </div>
                        ) : <div class="content-block block-missing-image"><p><em>Image missing or path incorrect.</em></p></div>;

                    case 'fullWidthEmbed':
                        return block.embedCode ? (
                            <div class="content-block block-full-width-embed" set:html={block.embedCode}></div>
                        ) : null;

                    case 'fullWidthText':
                        return block.text ? (
                            <div class="content-block block-full-width-text markdown-content" set:html={parseMarkdown(block.text)}></div>
                        ) : null;

                    case 'horizontalGallery':
                         return (
                            <div class="content-block block-horizontal-gallery">
                                <div class="gallery-scroll-container" id={galleryId}>
                                    {block.images && block.images.length > 0 ? (
                                        block.images.map(img => (
                                            img.image ? (
                                                <div class="gallery-item">
                                                    <Image
                                                        src={img.image}
                                                        alt={img.alt || ''}
                                                        width={800}
                                                        height={600}
                                                        format="webp"
                                                        quality={75}
                                                        loading="lazy"
                                                        densities={[1, 1.5]}
                                                    />
                                                </div>
                                            ) : null
                                        ))
                                    ) : (
                                        <div class="gallery-item placeholder"><p><em>No images in gallery.</em></p></div>
                                    )}
                                </div>
                                <button type="button" class="gallery-nav-button prev" id={prevBtnId} data-target={`#${galleryId}`} aria-label="Previous image">‹</button>
                                <button type="button" class="gallery-nav-button next" id={nextBtnId} data-target={`#${galleryId}`} aria-label="Next image">›</button>
                            </div>
                        );


                    default:
                        const unknownBlock = block as BaseBlock;
                        console.warn(`Unsupported content block type found in entry '${slug}':`, unknownBlock?.type || block);
                         return (
                             <div class="content-block block-unknown">
                                 <p><em>Unsupported block type: {unknownBlock?.type || 'Unknown'}. Check config and component.</em></p>
                             </div>
                         );
                }
            })
        ) : (
             entry.body ? (
                 <div class="content-block markdown-content" set:html={parseMarkdown(entry.body)}></div>
             ) : (
                 <p><em>No content found for this entry.</em></p>
             )
        )}
    </div>

    <hr class="entry-separator" />
</article>

{/* ADDED SCRIPT FOR GALLERY FUNCTIONALITY */}
<script>
    // This script runs for each FeedEntry component instance
    // It finds all horizontal galleries *within this specific FeedEntry* and sets up their controls.
    // This is better than a global script as it correctly scopes to each gallery instance.

    // Function to handle gallery navigation for a single gallery instance
    function setupGallery(galleryElement) {
        const scrollContainer = galleryElement.querySelector('.gallery-scroll-container');
        const prevButton = galleryElement.querySelector('.gallery-nav-button.prev');
        const nextButton = galleryElement.querySelector('.gallery-nav-button.next');
        const items = galleryElement.querySelectorAll('.gallery-item');

        if (!scrollContainer || !prevButton || !nextButton || items.length === 0) {
            // console.warn('Gallery elements not found for one of the galleries:', galleryElement);
            if (prevButton) prevButton.style.display = 'none';
            if (nextButton) nextButton.style.display = 'none';
            return;
        }

        const itemWidth = items[0].offsetWidth; // Assumes all items have the same width for snapping
        const gap = parseFloat(getComputedStyle(scrollContainer).gap) || 0; // Get gap value

        function updateButtonVisibility() {
            // A small tolerance helps with floating point inaccuracies
            const tolerance = 5;
            if (prevButton) {
                prevButton.classList.toggle('hidden', scrollContainer.scrollLeft <= tolerance);
            }
            if (nextButton) {
                nextButton.classList.toggle('hidden', scrollContainer.scrollLeft >= (scrollContainer.scrollWidth - scrollContainer.clientWidth - tolerance));
            }
        }

        prevButton.addEventListener('click', () => {
            const currentScroll = scrollContainer.scrollLeft;
            const targetScroll = currentScroll - itemWidth - gap;
            scrollContainer.scrollTo({ left: targetScroll, behavior: 'smooth' });
        });

        nextButton.addEventListener('click', () => {
            const currentScroll = scrollContainer.scrollLeft;
            const targetScroll = currentScroll + itemWidth + gap;
            scrollContainer.scrollTo({ left: targetScroll, behavior: 'smooth' });
        });

        scrollContainer.addEventListener('scroll', updateButtonVisibility, { passive: true });

        // Initial check
        updateButtonVisibility();

        // Update on resize as well, in case container/item widths change
        // Use a ResizeObserver for better performance than a global resize listener
        const resizeObserver = new ResizeObserver(_ => {
            // Recalculate itemWidth, may not be strictly necessary if it's percentage based and scroll is handled by browser
            // but button visibility might need re-check if clientWidth changes significantly
            updateButtonVisibility();
        });
        resizeObserver.observe(scrollContainer);
    }

    // Find all gallery blocks within this FeedEntry and set them up.
    // `document.querySelectorAll` used here will be scoped to the component's shadow DOM by Astro typically,
    // but since we're targeting elements by class within this component's template, it works.
    // To be absolutely sure it's scoped if issues arise, one could wrap the component's HTML in a div with a unique ID
    // and then use `document.getElementById(uniqueId).querySelectorAll(...)`.
    // However, Astro's script processing should handle this correctly.
    // For multiple galleries in one FeedEntry, this iterates through each.
    // The IDs prevBtnId, nextBtnId, galleryId are unique per block due to `slug` and `index` in their generation.
    // The script below selects based on class within the block.

    // Run this script after the DOM is ready for this component instance
    // Astro runs <script> tags by default with `type="module"`, which defers execution.
    // This should be fine.
    const galleriesInThisEntry = document.querySelectorAll('.block-horizontal-gallery');
    galleriesInThisEntry.forEach(galleryInstance => {
        // Ensure the gallery being set up is within the current <article class="feed-entry">
        // This is a sanity check. `astro:self` could refer to the shadow root if applicable.
        // For simple cases, direct query within the expected structure is okay.
        // The crucial part is that Astro processes this script per component instance.
        // The `id` attributes on buttons and scroll containers generated in the template
        // (e.g., galleryId, prevBtnId, nextBtnId) make them unique. The querySelectors inside setupGallery
        // are relative to the galleryElement passed to it.
        setupGallery(galleryInstance);
    });

</script>

<style>
    /* --- Base and Existing Styles --- */
    :root {
        --feed-entry-column-gap: var(--column-gap-desktop, var(--spacing-lg));
        --gallery-nav-button-size: 2.5rem;
        /* --- ADDED: Define gap size --- */
        --gallery-item-gap: var(--spacing-md); /* e.g., 1rem */
    }

    /* ... (keep all styles from .feed-entry down to .block-full-width-text) ... */
    .feed-entry { margin-bottom: var(--spacing-xl); padding-bottom: var(--spacing-md); scroll-margin-top: 2rem; }
    .feed-entry h3 { margin-top: 0; margin-bottom: var(--spacing-xxs); font-weight: var(--font-weight-bold); font-size: 1.1em; line-height: 1.3; }
    .feed-entry-date { display: block; font-size: 0.9em; color: var(--color-accent); margin-bottom: var(--spacing-md); }
    .feed-entry-blocks { margin-top: var(--spacing-lg); }
    .content-block { margin-bottom: var(--spacing-lg); }
    .content-block:last-child { margin-bottom: 0; }
    .block-two-column { display: flex; gap: var(--feed-entry-column-gap); }
    .block-two-column .column { flex: 1; min-width: 0; }
    .block-two-column .column > *:first-child { margin-top: 0; }
    .block-two-column .column > *:last-child { margin-bottom: 0; }
    
    /* MODIFICATION: Remove :global() for markdown content, styles will be in global.css */
    .block-two-column .column p, 
    .block-two-column .column li, 
    .block-two-column .column dt, 
    .block-two-column .column dd { 
        line-height: var(--line-height-unified); margin-bottom: var(--spacing-sm); font-size: 1em; 
    }
    .block-two-column .column h1, 
    .block-two-column .column h2, 
    .block-two-column .column h3, 
    .block-two-column .column h4 { 
        margin-bottom: var(--spacing-xs); margin-top: var(--spacing-md); line-height: 1.2; 
    }
    .block-two-column .column ul, 
    .block-two-column .column ol { 
        margin-bottom: var(--spacing-sm); padding-left: var(--spacing-lg); 
        /* list-style: revert; Ensure lists are styled if not caught by global */
    }
    .block-two-column .column li > p { 
        margin-bottom: var(--spacing-xxs); 
    }
    .block-two-column .column blockquote { 
        margin-left: var(--spacing-sm); padding-left: var(--spacing-md); border-left: 3px solid var(--color-border-light); color: var(--color-text-secondary); font-style: italic; margin-bottom: var(--spacing-sm); 
    }

    .block-full-width-image img, .block-full-width-image picture { display: block; width: 100%; height: auto; border-radius: var(--border-radius-sm); background-color: var(--color-border-light); }
    .block-missing-image p { font-style: italic; color: var(--color-text-secondary); background-color: var(--color-background-muted); padding: var(--spacing-md); border-radius: var(--border-radius-sm); text-align: center; }
    .block-full-width-embed { width: 100%; max-width: 100%; overflow: hidden; background-color: var(--color-border-light); }
    
    /* MODIFICATION: Remove :global() for markdown content, styles will be in global.css */
    .block-full-width-embed iframe, 
    .block-full-width-embed video { 
        display: block !important; width: 100% !important; max-width: 100% !important; height: auto !important; aspect-ratio: 16 / 9; border: none; margin: 0; 
    }
    .block-full-width-text {} /* Uses .markdown-content, which will be styled globally */


    /* --- UPDATED: Horizontal Gallery --- */
    .block-horizontal-gallery {
        position: relative;
        width: 100%;
        box-sizing: border-box;
    }
    .gallery-scroll-container {
        display: flex;
        overflow-x: auto !important;
        overflow-y: hidden;
        gap: var(--gallery-item-gap);
        padding-bottom: calc(var(--spacing-md) + var(--scrollbar-width));
        padding-left: calc(var(--gallery-nav-button-size) / 2 + var(--spacing-xs) + var(--gallery-item-gap) / 2);
        padding-right: calc(var(--gallery-nav-button-size) / 2 + var(--spacing-xs) + var(--gallery-item-gap) / 2);
        scroll-snap-type: x mandatory;
        scroll-padding-left: calc(var(--gallery-nav-button-size) / 2 + var(--spacing-xs) + var(--gallery-item-gap) / 2);
        scroll-padding-right: calc(var(--gallery-nav-button-size) / 2 + var(--spacing-xs) + var(--gallery-item-gap) / 2);
        scrollbar-width: thin;
        scrollbar-color: var(--scrollbar-thumb-color) var(--scrollbar-track-color);
        max-height: 70vh;
        width: 100%;
        box-sizing: border-box;
        margin-left: auto;
        margin-right: auto;
    }
    .gallery-scroll-container::-webkit-scrollbar { height: var(--scrollbar-width); }
    .gallery-scroll-container::-webkit-scrollbar-track { background: var(--scrollbar-track-color); border-radius: calc(var(--scrollbar-width) / 2); }
    .gallery-scroll-container::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb-color); border-radius: calc(var(--scrollbar-width) / 2); border: 2px solid var(--scrollbar-track-color); }

    .gallery-item {
        flex: 0 0 100%;
        min-width: 100%;
        scroll-snap-align: center;
        height: auto;
        max-height: 100%;
        border-radius: var(--border-radius-sm);
        overflow: hidden;
        background-color: var(--color-border-light);
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .gallery-item img, .gallery-item picture {
        display: block;
        width: auto;
        max-width: 100%;
        height: auto;
        max-height: 100%;
        aspect-ratio: 4 / 3;
        object-fit: contain;
        margin: 0 auto;
    }
     .gallery-item.placeholder p {
         font-style: italic;
         color: var(--color-text-secondary);
         padding: var(--spacing-md);
     }

    .gallery-nav-button {
        position: absolute; top: 50%; transform: translateY(-50%); z-index: 10;
        background-color: rgba(0, 0, 0, 0.5); color: white; border: none; border-radius: 50%;
        width: var(--gallery-nav-button-size); height: var(--gallery-nav-button-size);
        font-size: calc(var(--gallery-nav-button-size) * 0.6);
        line-height: var(--gallery-nav-button-size); text-align: center;
        cursor: pointer; opacity: 0.7; transition: opacity 0.2s ease, background-color 0.2s ease;
        padding: 0; display: flex; align-items: center; justify-content: center;
    }
    .gallery-nav-button:hover { opacity: 1; background-color: rgba(0, 0, 0, 0.7); }
    .gallery-nav-button.prev { left: var(--spacing-sm); }
    .gallery-nav-button.next { right: var(--spacing-sm); }
    .gallery-nav-button.hidden { display: none; }


    /* MODIFICATION: Remove :global() for markdown content, styles will be in global.css */
    /* Fallback Markdown Content - these rules are now intended to be in global.css under .markdown-content */
    /* .markdown-content p, .markdown-content ul, ... etc. REMOVED */
    
    .block-unknown p { font-style: italic; color: var(--color-text-secondary); border: 1px dashed var(--color-border); padding: var(--spacing-sm); }
    .entry-separator { border: none; border-top: var(--line-thickness) solid var(--color-border); margin-top: var(--spacing-xl); }
    
    @media (max-width: 768px) {
        :root {
             --gallery-item-gap: var(--spacing-sm); 
        }
        .feed-entry { margin-bottom: var(--spacing-lg); padding-bottom: var(--spacing-sm); scroll-margin-top: calc(var(--header-height-estimate-mobile-px, 92px) + 6rem); }
        .feed-entry-blocks { margin-top: var(--spacing-md); }
        .content-block { margin-bottom: var(--spacing-md); }
        .block-two-column { flex-direction: column; gap: var(--spacing-md); }
        .entry-separator { margin-top: var(--spacing-lg); }
        .feed-entry-date { font-size: 0.85em; }
        .gallery-scroll-container {
             gap: var(--gallery-item-gap); 
             max-height: 50vh;
             padding-left: calc(var(--gallery-nav-button-size) / 3 + var(--spacing-xs) + var(--gallery-item-gap) / 2);
             padding-right: calc(var(--gallery-nav-button-size) / 3 + var(--spacing-xs) + var(--gallery-item-gap) / 2);
             scroll-padding-left: calc(var(--gallery-nav-button-size) / 3 + var(--spacing-xs) + var(--gallery-item-gap) / 2);
             scroll-padding-right: calc(var(--gallery-nav-button-size) / 3 + var(--spacing-xs) + var(--gallery-item-gap) / 2);
        }
        .gallery-item img, .gallery-item picture { aspect-ratio: 4 / 3; }
        .gallery-nav-button { --gallery-nav-button-size: 2rem; }
         .gallery-nav-button.prev { left: var(--spacing-xs); }
         .gallery-nav-button.next { right: var(--spacing-xs); }
    }
</style>